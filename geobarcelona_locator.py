# -*- coding: utf-8 -*-
"""
/***************************************************************************
                               GeoBarcelona
 
 A QGIS plugin to search and zoom addresses in Barcelona city 
 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/

        copyright            : (C) 2019 by Javier Casado
        email                : javicasnov@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   any later version.                                                    *
 *                                                                         *
 ***************************************************************************/
"""

import json
import threading

from PyQt5 import QtGui
from PyQt5.QtGui import QColor
from PyQt5 import QtCore
from PyQt5.QtCore import QCoreApplication

from qgis.gui import QgsVertexMarker
from qgis.core import *

from functools import wraps

from . networkaccessmanager import NetworkAccessManager, RequestsException

class GeoBarcelonaLocatorFilter(QgsLocatorFilter):

    USER_AGENT = b'Mozilla/5.0 QGIS GeoBarcelonaLocatorFilter'
    
    def __init__(self, iface):
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.locmarker = QgsVertexMarker(self.canvas)
        self.t = PeriodicTimer(15.0, self.delete_marker)
        super(QgsLocatorFilter, self).__init__()

    def name(self):
        return self.__class__.__name__

    def clone(self):
        return GeoBarcelonaLocatorFilter(self.iface)

    def displayName(self):
        return 'GeoBarcelona'

    def prefix(self):
        return 'bcn'

    def delete_marker(self):
        self.canvas.scene().removeItem(self.locmarker)

    def fetchResults(self, search, context, feedback):

        if len(search) < 2:
            return
                
        search = search.strip()
        url = 'https://w33.bcn.cat/geoBCN/serveis/territori?q='+search+'&geometria=true&extensio=true'

        nam = NetworkAccessManager()
        
        try:

            # "Provide a valid HTTP Referer or User-Agent identifying the application (QGIS geocoder)"
            headers = {b'User-Agent': self.USER_AGENT}
            # use BLOCKING request, as fetchResults already has it's own thread!
            (response, content) = nam.request(url, headers=headers, blocking=True)
            
            if response.status_code == 200:  # other codes are handled by NetworkAccessManager
                
                content_string = content.decode('utf-8')
                locations = json.loads(content_string)
                root = locations['resultats']
                lid = root['adreces']
            
                if len(lid) != 0:

                    for count in range(len(lid)):

                        nomcomplet = lid[count]['nomComplet']
                        districte = lid[count]['districte']['descripcio']
                        barri = lid[count]['barri']['nom']
                        result = QgsLocatorResult()
                        result.filter = self
                        result.displayString = '{}, {}, {}'.format(nomcomplet, districte, barri)
                        result.userData = lid[count]
                        self.resultFetched.emit(result)

                else:
                    result = QgsLocatorResult()
                    result.filter = self
                    result.displayString = QCoreApplication.translate('GeoBarcelona Locator 1', u'No results found')
                    result.userData = []
                    self.resultFetched.emit(result)


        except RequestsException as err:
            
            self.info(err)
            result = QgsLocatorResult()
            result.filter = self
            
            if nam.http_call_result.status_code != None:
                result.displayString = QCoreApplication.translate('GeoBarcelona Locator 2', u'No results found')
            else:
                result.displayString = nam.http_call_result.reason

            result.userData = []
            self.resultFetched.emit(result)


    def triggerResult(self, result):
        
        dest_crs = QgsProject.instance().crs()
        doc = result.userData
        
        if len(doc)!=0:

            try:
                self.t.cancel()
            except:
                pass

            proj = doc['localitzacio']['proj']
            x = doc['localitzacio']['x']
            y = doc['localitzacio']['y']
            scale = 50

            results_crs = QgsCoordinateReferenceSystem(proj)
            transform = QgsCoordinateTransform(results_crs, dest_crs, QgsProject.instance())
            rect = QgsRectangle(float(x)-scale,float(y)-scale,float(x)+scale,float(y)+scale)
            r = transform.transformBoundingBox(rect)
            self.canvas.setExtent(r)
            
            pt = QgsPointXY(float(x),float(y))
            r_punt = transform.transform(pt)
            
            self.canvas.scene().removeItem(self.locmarker)
            self.locmarker = QgsVertexMarker(self.canvas)
            self.locmarker.setCenter(r_punt)
            self.locmarker.setColor(QColor(50,50,255,100))
            self.locmarker.setIconSize(8)
            self.locmarker.setIconType(QgsVertexMarker.ICON_CIRCLE)
            self.locmarker.setPenWidth(8)
            
            self.canvas.refresh()

            self.t.start()

    def info(self, msg=""):
        QgsMessageLog.logMessage('{} {}'.format(self.__class__.__name__, msg), 'GeoBarcelonaLocatorFilter', Qgis.Info)


class PeriodicTimer(object):
    
    def __init__(self, interval, callback):
        self.interval = interval

        @wraps(callback)
        def wrapper(*args, **kwargs):
            result = callback(*args, **kwargs)
            if result:
                self.thread = threading.Timer(self.interval,
                                              self.callback)
                self.thread.start()

        self.callback = wrapper

    def start(self):
        self.thread = threading.Timer(self.interval, self.callback)
        self.thread.start()

    def cancel(self):
        self.thread.cancel()
